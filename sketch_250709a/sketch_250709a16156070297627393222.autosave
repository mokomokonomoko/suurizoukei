import gab.opencv.*;
import processing.video.*;

OpenCV opencv;
Movie video;
Capture cam;

ArrayList<ExpandingCircle> circles = new ArrayList<ExpandingCircle>();

void setup() {
  size(640, 480);
  String[] cameras = Capture.list();

  if (cameras == null) {
    println("Failed to retrieve the list of available cameras, will try the default...");
    cam = new Capture(this, 640, 480);
  } else if (cameras.length == 0) {
    println("There are no cameras available for capture.");
    exit();
  } else {
    println("Available cameras:");
    printArray(cameras);

    // The camera can be initialized directly using an element
    // from the array returned by list():
    cam = new Capture(this, cameras[0]);

    // Or, the camera name can be retrieved from the list (you need
    // to enter valid a width, height, and frame rate for the camera).
    //cam = new Capture(this, 640, 480, "FaceTime HD Camera (Built-in)", 30);
  }

  // Start capturing the images from the camera
  cam.start();
  //video = new Movie(this, "sample1.mov");
  opencv = new OpenCV(this, 640, 480);
}

void draw() {
    background(0);

  if (mousePressed) {
    circles.add(new ExpandingCircle(new PVector(mouseX, mouseY), 10, 200, color(255, 150, 0)));
  }

  for (int i = circles.size() - 1; i >= 0; i--) {
    ExpandingCircle c = circles.get(i);
    c.update();
    c.display();
    if (c.isDead()) {
      circles.remove(i);
    }
  }

  if (cam.available()) {
    cam.read();
  }

  if (cam.width == 0 || cam.height == 0) return;

  // 🔁 カメラ画像を鏡映しにしてからOpenCVに渡す
  PGraphics flipped = createGraphics(cam.width, cam.height);
  flipped.beginDraw();
  flipped.pushMatrix();
  flipped.translate(cam.width, 0);
  flipped.scale(-1, 1);
  flipped.image(cam, 0, 0);
  flipped.popMatrix();
  flipped.endDraw();

  // 🔁 OpenCVに反転済み画像を渡す
  opencv.loadImage(flipped.get());
  opencv.calculateOpticalFlow();

  // 🔁 表示も反転画像
  //image(flipped, 0, 0);

  // 🔁 光の流れを描画（ベクトルの中心と方向）
  PVector aveFlow = opencv.getAverageFlow();
  int flowScale = 50;
  
  // 動きが強いときだけアニメーションを出す
if (aveFlow.mag() > 0.8) {
  float centerX = cam.width / 2;
  float centerY = cam.height / 2;

  // 鏡合わせなら反転（不要なら削除）
  float flippedX = cam.width - centerX;
  float flippedY = centerY;

  PVector pos = new PVector(flippedX, flippedY);
  color c = color(map(aveFlow.mag(), 0, 5, 100, 255), 200, 255);
  circles.add(new ExpandingCircle(pos, 10, 200, c));
}

  float centerX = cam.width / 2;
  float centerY = cam.height / 2;

  float flowX = aveFlow.x * flowScale;
  float flowY = aveFlow.y * flowScale;

  // 鏡合わせなのでX座標も反転
  float flippedStartX = cam.width - centerX;
  float flippedEndX   = cam.width - (centerX + flowX);

  stroke(255);
  strokeWeight(2);
  line(flippedStartX, centerY, flippedEndX, centerY + flowY);

  // 🔁 光の矢印が正しく反応するように統一
  opencv.drawOpticalFlow();
}
