import gab.opencv.*;
import processing.video.*;

OpenCV opencv;
Movie video;
Capture cam;

ArrayList<ExpandingCircle> circles = new ArrayList<ExpandingCircle>();

void setup() {
  size(640, 480);
  String[] cameras = Capture.list();

  if (cameras == null) {
    println("Failed to retrieve the list of available cameras, will try the default...");
    cam = new Capture(this, 640, 480);
  } else if (cameras.length == 0) {
    println("There are no cameras available for capture.");
    exit();
  } else {
    println("Available cameras:");
    printArray(cameras);

    // The camera can be initialized directly using an element
    // from the array returned by list():
    cam = new Capture(this, cameras[0]);

    // Or, the camera name can be retrieved from the list (you need
    // to enter valid a width, height, and frame rate for the camera).
    //cam = new Capture(this, 640, 480, "FaceTime HD Camera (Built-in)", 30);
  }

  // Start capturing the images from the camera
  cam.start();
  //video = new Movie(this, "sample1.mov");
  opencv = new OpenCV(this, 640, 480);
}

void draw() {
    background(0);

  if (mousePressed) {
    circles.add(new ExpandingCircle(new PVector(mouseX, mouseY), 10, 200, color(255, 150, 0)));
  }

  for (int i = circles.size() - 1; i >= 0; i--) {
    ExpandingCircle c = circles.get(i);
    c.update();
    c.display();
    if (c.isDead()) {
      circles.remove(i);
    }
  }

  if (cam.available()) {
    cam.read();
  }

  if (cam.width == 0 || cam.height == 0) return;

  // ğŸ” ã‚«ãƒ¡ãƒ©ç”»åƒã‚’é¡æ˜ ã—ã«ã—ã¦ã‹ã‚‰OpenCVã«æ¸¡ã™
  PGraphics flipped = createGraphics(cam.width, cam.height);
  flipped.beginDraw();
  flipped.pushMatrix();
  flipped.translate(cam.width, 0);
  flipped.scale(-1, 1);
  flipped.image(cam, 0, 0);
  flipped.popMatrix();
  flipped.endDraw();

  // ğŸ” OpenCVã«åè»¢æ¸ˆã¿ç”»åƒã‚’æ¸¡ã™
  opencv.loadImage(flipped.get());
  opencv.calculateOpticalFlow();

  // ğŸ” è¡¨ç¤ºã‚‚åè»¢ç”»åƒ
  //image(flipped, 0, 0);

  // ğŸ” å…‰ã®æµã‚Œã‚’æç”»ï¼ˆãƒ™ã‚¯ãƒˆãƒ«ã®ä¸­å¿ƒã¨æ–¹å‘ï¼‰
  PVector aveFlow = opencv.getAverageFlow();
  int flowScale = 50;
  
  // å‹•ããŒå¼·ã„ã¨ãã ã‘ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å‡ºã™
if (aveFlow.mag() > 0.8) {
  float centerX = cam.width / 2;
  float centerY = cam.height / 2;

  // é¡åˆã‚ã›ãªã‚‰åè»¢ï¼ˆä¸è¦ãªã‚‰å‰Šé™¤ï¼‰
  float flippedX = cam.width - centerX;
  float flippedY = centerY;

  PVector pos = new PVector(flippedX, flippedY);
  color c = color(map(aveFlow.mag(), 0, 5, 100, 255), 200, 255);
  circles.add(new ExpandingCircle(pos, 10, 200, c));
}

  float centerX = cam.width / 2;
  float centerY = cam.height / 2;

  float flowX = aveFlow.x * flowScale;
  float flowY = aveFlow.y * flowScale;

  // é¡åˆã‚ã›ãªã®ã§Xåº§æ¨™ã‚‚åè»¢
  float flippedStartX = cam.width - centerX;
  float flippedEndX   = cam.width - (centerX + flowX);

  stroke(255);
  strokeWeight(2);
  line(flippedStartX, centerY, flippedEndX, centerY + flowY);

  // ğŸ” å…‰ã®çŸ¢å°ãŒæ­£ã—ãåå¿œã™ã‚‹ã‚ˆã†ã«çµ±ä¸€
  opencv.drawOpticalFlow();
}
